
ls 'la '
ls ' la'
ls 'a a a a a'
ls ' a a a a'
ls 'a a a a '
ls ' a a a a '

(c'est surtout pour valgrind)



lol='     ls    '
$lol
$lol'-la'
$lol' -la'
$lol'-la '

ls ''
ls ''''
ls """"
ls ''""
ls ""''

ls 
(javais un invalid read sur non init parce que isquote était pas set à 0 et donc quand ça passait dans la fonction 





problem :


paul-f5Br3s6% make valgrind 
minishell$ ls '' '' '' ''
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
minishell$ 
make: *** [Makefile:128: valgrind] Error 2
paul-f5Br3s6% bsh
zsh: command not found: bsh
paul-f5Br3s6% bash
gbonis@paul-f5Br3s6:~/projets/third/ssh_maaike_minishell$ ls '' '' '' ''
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
gbonis@paul-f5Br3s6:~/projets/third/ssh_maaike_minishell$ 



aussi :

minishell$ ls '/proc/1' '..' '..'
..:
essai_waiter_philo  not_git_philo         test_philo
git_minishell       philo                 waiter_philo
maike_minishell     right_philo
minishell           ssh_maaike_minishell

/proc/1:
arch_status         limits         root
attr                loginuid       sched
autogroup           map_files      schedstat
auxv                maps           sessionid
cgroup              mem            setgroups
clear_refs          mountinfo      smaps
cmdline             mounts         smaps_rollup
comm                mountstats     stack
coredump_filter     net            stat
cpu_resctrl_groups  ns             statm
cpuset              numa_maps      status
cwd                 oom_adj        syscall
environ             oom_score      task
exe                 oom_score_adj  timens_offsets
fd                  pagemap        timers
fdinfo              patch_state    timerslack_ns
gid_map             personality    uid_map
io                  projid_map     wchan
minishell$ 


paul-f5Br3s6% make va
make: *** No rule to make target 'va'.  Stop.
paul-f5Br3s6% make valgrind 
minishell$ ls '' '' ''
lol
lol
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
minishell$ ls '' '' '' ''
lol
lol
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
minishell$ ls '' '' '' '' ''
lol
lol
lol
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
ls: cannot access '': No such file or directory
minishell$ 



ouai ici lol devrait se print le nombre de fois ou il y a un token avec des quotes, on voit bien que somehow je saute un token sur deux.

Et qu'est ce qu'il se passe si je melange les tokens avec quotes et sans quotes.


paul-f5Br3s6% 
paul-f5Br3s6% 
paul-f5Br3s6% 
paul-f5Br3s6% make valgrind 
minishell$ ls 'lol' pourquoi 'encore' poulet
lol
ls: cannot access 'lol': No such file or directory
ls: cannot access 'poulet': No such file or directory
minishell$ ls pourquoi oulet lol
ls: cannot access 'pourquoi': No such file or directory
ls: cannot access 'oulet': No such file or directory
ls: cannot access 'lol': No such file or directory
minishell$ 



paul-f5Br3s6% make valgrind 
minishell$ ls lol'lol'lol  aa'aaa'aa bb'bb'bb
1
2
ls: cannot access 'lollollol': No such file or directory
ls: cannot access 'bbaaabb': No such file or directory
minishell$ 

Il fait vraiment n'importe quoi avec les tokens



encore quelque chose de bizarre 

minishell$ ls 'lol' 'aaa' 'bbb'
1
2
ls: cannot access 'lol': No such file or directory
ls: cannot access 'aaa': No such file or directory
minishell$ ls 'lol' 'aaa' 'bbb' 'ccc'
1
2
ls: cannot access 'lol': No such file or directory
ls: cannot access 'aaa': No such file or directory
minishell$ ls 'lol' 'aaa' 'bbb' 'ccc' 'ddd'
1
2
3
ls: cannot access 'lol': No such file or directory
ls: cannot access 'aaa': No such file or directory
ls: cannot access 'bbb': No such file or directory
minishell$ ls 'lol' 'aaa' 'bbb' 'ccc' 'ddd' 'eee'
1
2
3
ls: cannot access 'lol': No such file or directory
ls: cannot access 'aaa': No such file or directory
ls: cannot access 'bbb': No such file or directory
minishell$ ls 'lol' 'aaa' 'bbb' 'ccc' 'ddd' 'eee' 'fff'
1
2
3
4
ls: cannot access 'lol': No such file or directory
ls: cannot access 'aaa': No such file or directory
ls: cannot access 'bbb': No such file or directory
ls: cannot access 'ccc': No such file or directory
minishell$ 



segfauult sur ce test la

ls: cannot access '': No such file or directory
minishell$ ls '11' 22' 33' 
0
1
2
make: *** [Makefile:128: valgrind] Segmentation fault (core dumped)
paul-f5Br3s6% make valgrind







maintenant probleme sur ça


minishell$ ls ' allo' 'pourquoi ' 'lol '
0
1
2
3
4
5
6
ls: cannot access ' allo': No such file or directory
ls: cannot access 'allopourquoi pourquoi': No such file or directory
ls: cannot access 'lol ': No such file or directory
ls: cannot access 'lol': No such file or directory
ls: cannot access "'lol": No such file or directory
ls: cannot access "'": No such file or directory
minishell$ 


Ouai, dois y avoir un probleme dans le x, je dois incrémenter trop, j;espere,si c;est que ça ce serait bien


ça veut dire que je vais devoir tester plusieurs token avec des quotes a la suite, ainsi qu'avec tous les autres cas interpolé, lol' 'lol, env var etc..



-still need to test with quotes in env var




---------------------------------------------------------

je reprends de zéro, l'autre commit fonctionnais mieux.
Je vais lister les tests qui fonctionnent pas.


OK:

'ls'
' ls'
'ls''
'ls '
''
'' ''
ls 'a a a a a a'
ls ' a a a a a '
ls 'a a a a a a '
ls ' a a a a a a'
ls '-la'
ls ' -la'
ls '-la '
ls '' ''
'ls' '-la'
'ls' ' -la'
'ls' '-la '
ls '"lol"'
ls "'lol'"
ls '"a a a a a"'
'ls' '" a a a a a "'
ls '"a a a a a "'
ls '" a a a a a"  '
ls '     "aaa"     '
ls '   ""   '
'ls' '  "" '
"ls" "   ''   "
"ls" '    ""   '
"ls"  '    "   "    '
'ls ""   '
'ls""   '
l's' -la
l's ' '-la'
ls 
ls "" ''
ls 'allo' 'pourquoi'
'ls' ''
ls ' put a tab with ctrl=v here '
ls aaaaa'      'aaaaa	
ls aaa'   'aaaaa
ls aaa'   'aaaaa
ls aaaaaaaaa'  'aaa
ls aa'  'aaaaaaa
ls  aa'          'aa
ls aaaaaa'                      'aa
ls aa'            'aaaaaaaaa
ls aaaaa'      'aaaaaaaaaaa
ls "" '  '
ls '' '   '
ls aaa'     aaa'aaa''
lsaaa'    aa'aa''
'ls''''	
'ls' ''''
'ls' ''''''
ls  aaa''aaaa
'ls'""''			
'ls' ""''""'a'
'ls' ''''''''
ls ''""		
ls ""''			
ls ''''aa
ls ""''aa
ls ''""aa
ls aa''''aa
ls aaa'    'bbbb'   'ccc	
ls aaa'   ''   'ccc
ls '    ''    '
ls aaa'   ''   'aaa
ls aaa"   "'   'aaa
ls '   '"   "
ls "    "'   '
ls'   ''   '
ls '     ''     ''      '
ls '     '"      "'     '"      "
ls '     'aaa'      'aa'     'aa	
ls '     'aaa"     "aa'    'aa	
ls 'allo''pourquoi''lol'
l's''lol'
l's'"    lol"
l's''    lol'	
ls '      ''lol'
ls '../''     '
ls '      ''..'
ls aaa'       ''..'aaa
ls ' allol '' allol '' lol '
ls aa'   aaa   'ddd'   aa  'ddd' aaaaa    'sss
ls '    aaaaa''      aaaaa''     aaaa'
ls aa'    aaaaa'sls'      aaaaa'aaaa'     aaaa'sss
ls aaa'aaaa     'aaa'aaaaa    'aaa'aaa    'aaa
ls '  ddddddd   ''   ddddddd  ''    dddd '
ls '  a  ''   s  ''    ddddd     '
ls '  a  '' ss  ''   ssss '
ls aaaa'    aaaa'aaaa'     aaa'aaaa'     '''
ls aaaa'      ''     ''       '
ls aaaaa'        'aaa'       '
ls ''''''''
ls '" pourquoi lol encore"    ' 
ls '" wwwwww eee eeeeeeeeeeeeeee"     '
ls aaa"aaaa"'    a'aaaa
ls aaaa'     aaaaa'aaaa'    aaa'aaaaa''
'ls' allo'allo'allo
"ls" 'allo'allo"allo"
ls aaaa' 'aaaaaaaaa sssss' 'aa s' 'ssssssssss
ls aaaa'     'aaaaa aaaaa"     "aaaa
ls pourquoi'allo'lol"pourquoi"allo
'ls' a''''a'''s' 
ls aaa'aaa'aaa's's sss'sss'sss'ss'ss
ls '    '    '   '  '   ''      '
ls '   ''    '  '     ''    '
ls '    a    ''    a   '    'dddd      '
ls aaaaaaaaaaa'aaaaaaa'aaaaaaa aaaaaaa'aaaaaaa'aaaaaaa saaaaaaaaaaa'aaaaaaa'aaaaaaaaaa   'aaaa'a aaaaaaaaa'aaaaaaaaaaaaa' 'aaaaa' 'aaaaaaaaaa' 'aaaaaaaaaaa'
ls ""''
ls ''""
ls '    ''    '
ls '   ''    '   '     ''    '


lol="'a'"
ls aaa'    '$lol'    'aaaa     // lol = 'a'
ls '     '$lol'    '
ls aaaa'    $lol'   'aaa'     '$lol'    'aaaa
ls aaa'   ''   'aaa
ls aaa"   "'   'aaa
ls '   '"   "
ls "    "'   '
ls '     ''     '$lol'    '		
ls aa'aaa'$lol'aaa'$lol'dddd'$lol 'dddd'$lol'dddd'$lol
ls'   ''   '
ls $lol'   'aa			
ls '   '$lol'   ' 


lol = "'aa "
ls '   '$lol'    '
ls $lol'   'aaaa'    'aaaa

lol="'aaa '"
ls '   '$lol'   ' 		
lol=' aa"'
ls $lol'dddddd'dddd'    '$lol'     'dddd$lol			//NON
ls $lol'     'ddd$lol    // celle la c'est bon jsp pq

lol="''''"
ls $lol'pourquoi'$lol'allo'
ls $lol"pourquoi"$lol"allo"
ls $lol'pourquoi'$lol"allo"
ls $lol'pourquoi'$lol'allo'$lol
ls $lol'       '$lol'       '$lol
etc.. quote vides etc..

lol="''''" 
ls $lol'     '$lol'    '$lol
ls $lol"     "$lol"     "$lol
ls $lol'     '$lol"     "$lol
ls $lol'    '$pourquoi'      '$lol avec pourquoi ave des diff type quotes

lol="'a'"
ls $lol'   'aaaa'    'aaaa		
lol="''''"
ls $lol"        "$lol"      "$lol

lol="''''" 
ls $lol'     '$lol'    '$lol $lol'     '$lol'    '$lol

lol="''''"
ls $lol"sssss"$lol"    "$lol

lol="'aa"
ls $lol'   'sss'   'ss

lol="''''"
ls $lol"sssss"$lol"    "$lol  $lol"sssss"$lol"    "$lol


lol='' ou lol=

ls $lol pourquoi
ls $lol

NOT OK:

//////ATTENTION J'AI UN GROS BLINDSPOT SUR MES TESTS, J'AI QUASIEMENT AUCUNE VARIATION SUR LE PREMIER TOKEN (COMMANDE) /////








-ouai, pour le truc sur les quotes ls 'allo''pourquoi' etc.. c'est un truc assez gros a fix,
ou alors je peux me dire que tant que je suis dans un token de split  je check si ya un nombre de quote pair, et si c'est le cas je met tout sur un token ?
Mais il y a aussi le probleme que 


En fait faut juste que je build une infra lorsque les quotes sont collées.



Ouai déjà je peux me dire que je fais le cas ou dans un token de split on a des quotes pairs, donc la c'est bon je peux faire. Mais si les type sont impair, a ce moment
la ça veut dire, non mais c'est une histoire de cmd_str de toute manière non ?
Ouai en fait d'une manière ou d'une autre je dois avoir un detecteur dans le token de split si type est impair ou pair, mais je crois que je gere deja les token genre aaaa'     'aaaa
Peut etre on peut dire que si je détecte que dans un token ce ya des quotes au dessus de 2.
Non mais je serais obligé de regarder dans la cmd str de toute manière, 

Ouai je peux juste checker dans le inside size si ya une quote juste après la deuxieme quote et si c'est le cas je continue
Aussi je dois checker comment je copie pour faire ça

OLA, MAIS IL SE PASSE QUOI SI AU MILIEU IL Y A UNE ENV VAR ?
Évidemment il faut la gérer, donc je dois faire ça en aller parmi les split tok aussi ? ou alors je fais avec l'env var direct ?
Ah ouai mais non en fait dès que ya pas de quote après dans la cmd str c'est bon on fait le taf dans le split tok ? et i je détecte encore une quote après je repart dans la str etc..
et dans tout ça je dois manager le count aussi,
car je dois etre capable de faire ls 'allo'$HOME'pourquoi       ' 'allo'   donc avec le dernier espace avant allo 

En gros je dois juste build un reconnaisseur de quotes que je manage le token avec la première quote que je trouve et gérer count accordingly ainsi que le free des tokens etc..




Pour faire ça je pense pas qu'il y aura des problemes avec check if pass parce que  c'est vis a vis des env var, je dois build ce que j'ai dis mais tout en respectant la logique
du reste du programme, qui je pense n'est pas mauvaise.

Aussi, j'oubliais, on doit etre capable de faire tout ce que je viens de dire avec des quotes différentes.
Je pense pas que ce soit trop difficile a faire, je dois juste faire attention a bien gerer count et les token du split.

Ouai si je mets un détecteur de quotes, peut importe le type ou quoi, après que je sorte de l'inside de cmd_str, ça devrait aller, et si je gere bien  count. Ouai parce que 
normalement j'ai géré le fait d'aller dans un autre token de split, donc meme si je tombe sur une env var ça devrait aller, ouai mais non en fait parce que si ya des quotes
dans l'env var je dois sauter autant de quote que ça non ?

Tout ça ça parait compliqué mais je pense que c'est pas grave, toujours dans ma méthode de pas avoir du code complexe pour des situations non complexes etc..
Ah mais attends, j'ai déjà le tableau pour dire combien de quotes je dois skip non ? donc ça devrait pas etre trop compliqué non ?
Pour faire ça je dois vraiment faire une structure spéciale pour tout ce parsing là

Ouai si je résume c'est vraiment 




-verif le tab pour voir si je peux l'utiliser
	Oui le tab fonctionne comme ça, donc je peux utiliser le tab pour build cette infra.


construire une struct





Ouai aussi car pour un cas comme ls 'something'$lol'    pourquoi'   avec $lol ou ya des espaces dedans je dois pas mettre ça dans un seul token non ?
	ouai->
		gbonis@paul-f5Br3s6:~/projets/third/ssh_maaike_minishell$ export lol='pourquoi   '
		gbonis@paul-f5Br3s6:~/projets/third/ssh_maaike_minishell$ ls 'something'$lol'else'
		ls: cannot access 'somethingpourquoi': No such file or directory
		ls: cannot access 'else': No such file or directory
		gbonis@paul-f5Br3s6:~/projets/third/ssh_maaike_minishell$ 
Donc ça voudrait dire que je dois juste regarder après l'inside quotes, et si je trouve une quote dans le token, meme après une env var ou pas je sais pas, je repasse dans l'inside etc..

Je pense pas que ce soit trop difficile de build ça, c'est juste qu'après je devrais bien revenir dans le loop comme avant et continuer au bon endroit, pour tous les autres cas etcc (les cas normaux)
En gros la stratégie ça va être de build l'infra pour ce cas spécial la sans toucher au reste au niveau de la logique, donc vraiment de passer autour de tout ça, donc pour aller dans ce module du
programme je dois vraiment juste checker après l'inside de la premiere quote si ya une quote valide (skip le tableau) repartir dans l'insidecmd_str etc etc..


pour faire ça, premierement faire des tests avec les env var et les quote pour voir si ça fonctionne, comme j'ai pas vraiment testé ça, ensuite changer les args des fonctions pour avoir
une struct avec tout pour pouvoir passer plus facilement les choses et pouvoir respirer dans les fonctions que je fait.


Ouai mais ça veut dire que je devrais aussi gérer le tab (je crois que c'est le z dans le gros loop) dans les cas ou je saute des quotes et en gros ou je colle
ensemble plusieurs quotes)



-test env var with quotes
-build struct











TEST ENV VAR:

OK:
export lol="' ' '"
ls $lol'pourquoi'
ls $lol' pourquoi'
ls $lol' pourquoi '



NOT OK:



/////// pour ce cas la ce qu'il semble se passer c'est que je prends pas en compte la derniere quote de la env var alors que je devrait, et que 
je print la derniere alors que je devraispa for some reason. Ah mais attends peut etre que c'est parce que dans le tableau des quotes a skipper je skip littéralement
toutes les quotes des env var alors que je devrais pas les skipper si elles sont accrochées. donc ce serait le tab qui est mauvais


je vais déjà build les quotes après et on verra


AH OUI EN FAIT JE PENSE QUE C'EST DU AU FAIT QUE JE RETURN LE TOKEN QUAND YA LES DEUX QUOTES DEDANS OU QUELQUE CHOSE COMME ÇA





(pour la suite de minishell, ne rien viser sur le timing, juste faire le protocole 10h par jour et le reste, pas de manga etc, et on 
verra si je bh ou pas)











//////////////


Ouai en fait ce que l'on doit gérer c'est lorsqu'on sort de l'inside string, le token dans lequel on est, on a juste besoin de checker si ya une autre quote la dedans, tout en vérifiant
que l'on soit pas dans une quote du tableau qu'il ne faut pas prendre en compte.


JE VAIS SUREMENT DEVOIR CHANGER QUELQUE CHOSE SUR TYPE DANS LE CAS ls 'pourquoi'"allo"'bonjour' CAR SINON JE PERDS LE TYPE DAVANT ?









autre probleme 


minishell$ 
paul-f5Br3s6% export lol="' ' '"
paul-f5Br3s6% make valgrind 
minishell$ ls $lolpourquoi
a.out  inc  libft  LICENSE  log  Makefile  minishell  obj  src  test.c  to_do
minishell$ ls $lol'' pourquoi
ls: cannot access "'": No such file or directory
ls: cannot access "'": No such file or directory
ls: cannot access '': No such file or directory
ls: cannot access 'pourquoi': No such file or directory
minishell$ 


///// probablement ce bug ne sera pas fixed lorsque l'env var sera derriere















/////////////////

-donc pour le ls $lol' pourquoi' avec lol="' ' '", la raison c'est que je check dans les token pour skipper le nombre de quote, mais je check pas une fois que je suis dans le token lui meme. Le probleme
vien de la boucle ou je copie avant cmd_str, car je check juste pour type, et donc si ya une quote d'une env var ça merde car ça stop sur la quote, enfin bref ça merde quoi. Je dois trouver un moyen 
de faire en sorte que je print la quote de l'env var.

Je pense que je peux lors du pass choper la position de la bonne quote et après et au lieu de checker sur le type dans la copy avant cmd_str je copie jusquá cette position





-TOUT CE QUE JE FAIS POUR GERER QUOTE ENV VAR AVANT QUOTE TOKEN CA SERA PROB A FAIRE APRES QUOTE TOKEN AUSSI, TESTER AVEC UNE ENV VAR AVEC QUOTE APRÈS QUOTE TOKEN





------------------------------------------


ouai pour le cas ls 'allo''pourquoi''etc' je pense que je peux juste checker dans le rest du split apres la inside size, et i ya une quote dedans avec le tab décrémenté (par ex si ya ''' dans une env var et
juste collé après une quote d'un token de quote, et si c'est le cas et bien de je repart dans les fonctions des getsize etc.. Normalement ce comportement devrait fonctionner, car si on ne trouve pas 
de quote dans l'envar (ou dans les tokens split) meme si dans la cmd_str_b c'est 'allo'$envarquote'test' ce sera cut en terme de token. Oui, maintenant par rapport a la gestion des tokens après ça.

Je pense que d'après le code que j'ai déjà fait je pense que j'ai pas besoin de manager les indices quand je copy le new token, je peux tout gérer après, mais je dois pas toucher au tab quand je fais ça, parce que
je dois pouvoir sauter les quotes des envvar dans les tokens de split, oui c'est juste ça en fait, normalement tout sera fait, je dois juste pouvoir trouver le bon token après, et pour cela je dois juste
savoir combien de quotes je dois sauter.

Verifier que le tab bouge pas


-gerer le copy in tok sans penser a après
-avoir le new tok
-manager les token après via le tab pour réussir a free et manager l'indice jusq'au token d'après
-repartir dans la boucle principal au bon endroit.

Normalement je devrais pas avoir a toucher tellement au code qui est autour, essayer en tout cas de faire comme ça



FAIRE GAFFE AVEC COUNT, ÇA RISQUE D"ETRE COMPLIQUÉ PUISQUE JE DOIS GERE ČA AUSSI
Là count est juste incrémenté dans la boucle, je pense que je ne dois pas toucher à ça, mais je dois le passer dans les fonctions de quote pour pouvoir le gérer lorsqu'il y a plusieurs quotes viables
dans un seul split token et que je dois en somme créer un split token avec deux quotes qui compte pour count.
Je pense que je dois incrémenter count dans les fonctions de quote seulement pour ce cas et pas toucher au reste des cas pour pas les péter.
Ah ouai j'avais aussi oublié l'histoire selon laquelle je dois pouvoir gérer count sur un seul token comme ça mais avec deux types de quotes genre ls 'allo'"lol".
Boarf, ça devrait pas être trop compliqué. Je dois juste checker que je manipule pas deja count quelque part.

Aussi je me dis que une fois que l'on est dans le parsing d'un token de quote, une fois qu'on est sorti du premier, si ya des trucs après, et surtout si ya des quotes valables, on s'en fout à ce moment
la du type des quotes, parce la prochaine que l'on rencontre, simple ou double, d'ailleurs on peut rewrite type a ce moment la, comme c'est un pointer, de toute maniere une fois qu'on sort du managing
de ce token je crois que count est redéfini, donc c'est pas grave si c'est pas le meme type, verifier ça. Oui en effet c'est bien le cas.

Aussi je pense que je peux utiliser les fontions de size pour checker et avoir la size inside et outside des quotes. Je veux dire que j'ai pas de réécrire des fonctions ou de faire plus de logique.

Ouai pour count, j'y ai accès dans la struct, mais aussi c'est pas difficile d'incrémenter le compteur je pense, j'aurais juste besoin de regarder le type et voila, par, ouai en fait le seul truc que 
j'aurais besoin de faire c'est d'incrémenter count pour le type d'avant avant de changer le type pour un nouveau type de quote, et après si le type change pas c'est pas grave on remet invariablement le
meme type dans type et voila, et c'est le dernier type qui ne devra pas etre incrémenter et se fera incrémenté après en sortant de manage q tok dans la boucle de quote parsing.
Juste pour etre sur je dois checker pourquoi j'utilise count, je crois que c'est pour checker les bonnes quotes dans la cmd_str.
Oui je viens de checker et en effet je touche pas a count (dans la logique du code, parce que litteralement j'y touche mais j'ai un temp après pour revenir a la vraie valeur)
Ouai j'ai verif et je touche a count, et l'utilise, en effet seulement dans le copy de la cmd_str, en fait je touche meme pas, ce que je veux dire c'est que je peux incrémenter count
comme je veux c'est pas grave.
Ou peut etre non justement je devrais juste incrémenter count pas dans get size mais dans le copy, parce que si j'incrémente dans dans get size copy_in tok ne copiera pas les bon trucs. Je dois juste
me rappeler que je dois incrémenter seulement jusqu'à la dernière quote.





















(je pensais aussi a comment je vais faire pour les double quotes ou je dois faire les expand, mais je pense que c'est assez facile vu que je dois juste regarder le type et checker pour des dollars et
après je mets toutes les fonctions qui managent les env var, je veux dire que c'est pas trop difficile d'intégrer ça dans le code que j'ai fait je pense. Par contre je devrais aussi checker pour le type
et les expand dans le get size pour le malloc des quotes aussi parce que sinon j'aurais pas la bonne size. Ce que je veux dire avec tout ça c'est que je pense que je ne pourrais pas faire une pass après
les quotes, attends si, peutetre que c'est mieux, ouai probablement, je peux juste faire ça une fois que j'ai bien clean les token de split, à ce moment j'aurais juste besoin d'un tab pour voir si je dois sauter
dans les tokens de split des $ (en gros juste gérer ceux qui sont dans les double quotes (oui parce que il peut y en avoir dans les env var en théorie, et donc je dois savoir si je dois combien je dois skip
de $ non valable dans les tokens, car a ce moment la il ne restera que les eventuels qui ne sont pas dans, 
Ouai, encore une fois je pense que c'est bon si je fait encore un tab et que je check pour les $ a l'intérieur des env var, puis a nouveau a l'interieur des quotes, comme je disais pour je ne sais plus quel
tableau.
Si je me souvient bien je fais du coup faire les 3 tableaux dans get counter etc.. et après faire séparément le cutting et managing de strings, ce sera plus clean comme ça, comme je crois que c'est assez simple
pour moi de fabriquer des tableaux en plus vu comment j'ai codé le get counter, je peux juste insérer tout ce qu'il faut la dans les fonctions et aussi vu que je skip le characteres entre les quotes je peux
aussi facilement mettre des checks dans les quotes pour des dollars etc.. je dois verif que c'est easy de checker dans les env var et aussi que j'ai le type quand je check dans les quotes. Oui je viens de regarder
ça me parait pas trop difficile.




---------

probablement je peux utiliser la fonction if pass ou jsplus quoi a la sortie de l'inside size dans le token de split correspondant pour voir si ya un quote valid, et comme ça j'incrémente
automatiquement le tab.
Et aussi comme ça j'ai la q->pos








------
Je viens de voir que je ne peux pas faire des temps sur le tab, si je dois utiliser le tab après pour les redpip tok, je devrais dupliquer le tab avant que je l'utilise dans les quotes











































-----
Je viens de penser à quelque chose, lorsque j'ai un redpip token au milieu d'un token genre 'pourquoi'>'allo' je devrais dans la tokenize string alors avoir trois token plutot qu'un ?
Oui, mais ça change pas grand chose, ce sera juste du managing de strings dans tokenised string, du moment que j'ai le bon tab je pourrais gérer ça, car ce cas là c'est juste dans un
token split quand yen a plusieurs, j'aurais juste besoin de compter, ouai d'ailleurs parce que je peux avoir un truc comme ls |wc|wc|wc|wc|wc|wc| wc etc.. et donc je devrais pouvoir gérer ce genre de cas la aussi.

Oui je viens de tester c'est bien le cas.


Ouai je devrais avoir une fonction de detecteur de token qui renvoie le type de redpip token que c'est pour que je puisse mettre ça dans le tab 











lol="'a'

ls ""''
ls ''""
ls '    ''    '
ls '   ''    '   '     ''    '
ls aaa'    '$lol'    'aaaa
ls '     '$lol'    '
ls aaaa'    $lol'   'aaa'     '$lol'    'aaaa
ls aaa'   ''   'aaa
ls aaa"   "'   'aaa
ls '   '"   "
ls "    "'   '
ls '     ''     '$lol'    '
ls'   ''   '

Faire des tests aussi lorsque $lol n'existepas

avec lol="'aaa '"

ls '   '$lol'   ' 


avec lol='"aa '

ls $lol'   'aaaa'    'aaaa a pas l'air de fonctionner. non ça fonctionne, c'était le deuxieme token apres ls les size javais pas compris









Je pense que je devrais utiliser les memes fonctions pour copier dans le nouveau token, mais avant, je dois retester les autres cas avec les fonctions get_size que j'ai changé





peut etre que pour le probleme de ls aa'   'aaa aaa'    'aa aaa'    'aaa pour le tab, je peux faire une copie temporaire du tab. Ouai mais non en fait le probleme c'est que j'ai juste pas encore 
gérée la sortie de tout ça, donc si jamais j'ai incrémenté le tab etc, ça veut aussi dire que je vais devoir sauter des tokens, ce que je gere pas maintenant. Ouai mais attends pq j'aurais besoin 
d'en sauter dans ce cas la c'est as logique





-------------------------------------

Pour le copy dans le new tok pour les tokens collés, je pense que je peux copier dans le token via deux fonctions, copy inside et copy outside, meme si je saute des endroits
dans la mem c'est pas grave, c'est plus pratique comme ça, faut juste qu'il n'y ai pas de bugs dans les fonctions get size. Parce que je pense que je dois réutiliser le code 
de ces fonctions et de juste copier au lieu de compter.
Lol peut etre je peux avoir une seul fonction et donner un flag pour savoir si la fonction doit chercher ou copier.



a faire:
	- test si coun_next_quote est en effet changé dans inside size
	- test si type change aussi dnas inside size

non les deux cest bon, type est passé by value, et normalement count next quote est recalculé






test copy in tok












-Pour le probleme de 'ls' ''""''""'a'

D'abord faire un essai en remmettant z sur la valeur avant, meme si ça fonctionne pas et que je devrais dupliquer le tableau si je veux que ça fonctionne avec
les env var etc..
Mais pour l'instant juste dupliquer le z, car dans cet exemple normalement ça va fonctionner






-------

j'ai trouvé la raison pourquoi, c'est juste que j'ai pas géré la sortie encore. Alors ya un probleme sur ma maniere de compter
dans la cmd_str_b dnas le get i de copy outside, il prends en compte le premier token de quote de la cmd_str_b et donc c'est pas bon 
il copie pas les bons trucs.

Et ya aussi l'histoire avec le tableau qui fonctionnera pas pour les env var comme je disais avant





-----


ls probleme pour ls a'     'aaaaa a'     'aaaaa c'est que j'utilise pas count pour de  get i, mais je dois vérifier que
count_next_quote c'est useless du coup, mais je sais plus a quoi ça sert. 
-> verif a quoi ca sert


OK, je crois que j'ai compris, count[] c'est pour avoir le debut de la ou copier/avoir la size, et count next quote c'est pour savoir
combien de quote dans le meme token de split on doit avoir




Oui je comprends petit a petit, le cas ls a'    'aaaaa a'      'aaaaa ne fonctionne pas juste parce que j'ai juste pas géré la sortie
de manage tok sur count (je dois incrémenter count pas juste dans quote parsing sur la premiere quote mais sur toutes les quotes
sur lesquelles je passsent. Aussi je dois aussi revoir comment je gere de next quote counter pour voir si ça va mais ça normalement
c;est jsute dans un seul token de split donc c'est set a 0 quadn on repart dans quote parsing. Mais je dois gérer coun[] pour partir
du bon endroit dans copy outside inside etc rechecker tout ça.

Mais pour l'instant je dois finir de clean sur un seul token avec plusieurs quote collées, free les useless tokens et bien incrémenter
les trucs etc.. et après je gérerais le cas dont je parle (ainsi que les autres avec env var)


Ouai en fait dans mon exemple avec ls a'    'aaaa a'       'aaaaa count eest a 1 quand je suis dans le deuxieme token qui il s'est incrémenté
dnas quote parsing, et cest tout, ya rien dautre qui incrément ça.

je dois regarder si le fait d'avoir plusieurs quotes dnas le meme token ca fonctionne sur le premier deja et si c'est le cas j'aurais
plus qu'a mettre le i au bon endroit et on sera bien





------

tous les cas dans ok sont clean, je dois maintenant gerer la sortie pour un seul token plueiurs quote, (il manque le free a gerer)
Puis après je dois faire plusieurs token a la suite avec plusieurs quotes, (donc gerer la sortie et la rerentré dnas les fonctions
de copy, puis après tester avec les env var. Puis ensuite continuer sur le pass pour les doubles quotes ainsi que donc doubler les tableaux
et construire les nouveaux tableaux necessaires comme javais dit avant.





-----------------

La je suis en train de tout build pour pouvoir faire les multiple quote in single token and multiple of those token. Apres je verrais et
testerais avec les envvar avec quotes. Pour l'instant juste build sans env var, de toutemaniere je devrais juste utiliser le tab dans les
fonctions, après je devrais cehcker et voir i je dois le temp ou le duppliquer.
Mais pour l'instant on dirait que mon code pour un seul multiple token fonctionne, je dois juste probablement juste adapter la data qui me sert
a faire ça (temp ou dup), ainsi que bien set up la sortie de boucle pour pouvoir repartir



pour count next quote normalement la data est toujours la pour le manage rest tok. Je dois checker pour le tab, je crois que jai pas trop le choix de 
l'incŕementer directement et que je vais devoir faire une copie.

DEJA ESSAYER SANS ENVAR AVEC COUNT NEXT QUOTE POUR VOIR IS CA FONCTIONNE




was working on 59 manage rest tok








----------------------

pour la sortie multiple multiple q tok

checker count
checker tab






Ouai en  fait le probleme avec tab c'est qu'on est obligé de checker pour les env var meme entre les quotes dans un singletok multiple quote
Aussi je dois verifier la gueule du tab.
Ouai c'est bizarre quand je regarde le tab, normalement les values du tab sont plus la pour la copy, ouai mais c'est normal en fait, c'est parce que 
j'ai pas testé avecdes env var encore, sinon j'aurais vu que ça fonctionne pas.

Je pense que je dois deja travailler sur count et régler le proble,e dincrementation entre les call de manag_q_tok, faire passer tous les tests, et après
on verra pour le tab, ou et comment le duppliquer

Count je crois que a part lincrementation en sortie on est bon
Ouai on est bon mais justeement un peu trop, a la sortie des fonctions size et copy il faudra trouver un moyen de bien incrémenter count. Je pense 
que pas toucher au fonctions de sixe et copy c'est  mieux, comme elle utilise toutes les deux la meme fonction autant en faire une autre et incrémenter
manuellement en sortie après que tout soit fait.





-----------------------



-pour incrémenter count on peut juste utiliser count next quote,  comme normalement on a pris en compte tab (meme si en ce moment je crois pas que tab
fonctionne correctement car je dois duppliquer tab a un moment, je sais plus si c'est entre size et copy ou si cest entre les multiples multples tok


en fait en ce moment le tab "fonctionne" parce que ya rien dedans (que des 0) parce que je teste pas avec des env var, mais si je commence a tester avec des env var et des quotes
ça peterais tout, et que je temp juste le z lorsque j'utilise le tableau. peut etre je peux temp a la fois le z, mais aussi les valeurs du tableau lorsque je l'utilise ?


deja on va faire count, on verra après pour tab
Le probleme aussi c'est que count next quote repose sur un tab qui fonctionne, si tab ne fonctionn pas count next quote ne sera pas accurate.





-------------------------

j'incŕmente count lorsque ya des mutliples quotes tok, mais que se passe t il lorqu'il n'y a qu'un seul pair de quotes, est ce que je laisse quote pars incrémenter count? non je ne pense
pas car sinon ce serait compliqué, entre gére le changement de type si jamais dans mutiple tok, et aussi gérer le cas dans manage count de quand il y a une seule pairs de quote, je 
pense que c'est plus simple de faire un seul endroit ou on manage count.




en fait pour count dans les fonctions qui manage le nouveau token, on est sur a priori d'avoir le bon type quand on commence a checker avec count (le bon type pour la premiere quote que l'on
va rencontrer) Et donc pour l'entrée dans la foncion on peut checker avec type, c'est après que l'on devra probablement faire attention a lorsque ça change de type de quotes.
 
Et en ce moment ça fonctionne car lorsque j'ai un token avec des quotes non multiple au debut, genre 'ls', count est incrémenté dans quote parsing, et après dans la cmd_strb tout fonctionne
car on a la bonne quote de base, et count est bien incrémenté pour sauter les quotes deja utilisées.
Non je viens de voir qu'il y a un probleme.
 
aves 'ls' "allo"allo'allo'
   
 
 
 
Ah ouai en fait indépendamment de token avec multiple quote, je crois que meme des tokens avec plusieurs quotes d'affilée ça fonctionne pas. Et qu'il y a un probleme dans get next i de
copy outside.
 
 
 
   
   
   
 
Ouai je viens de trouver le probleme, 
 
ls a'   'a  sss'   'sss ddddddd'      'dddddddd
 
Avec une commande comme ça, ya rien qui fonctionne en fait. A cause de la fonction get next i dans copy outside
 
 
en fait ça fonctionne, mais seulement pour la premiere occurrence, je dois juste corriger pour que les autres ois ça va
 
Ouai dès que je mets 'ls' avant ça exploser complètement les choses.





Première chose, corriger la fontion dans copy outside pour qu'elle fonctionne lorsqu'il y a des multiples quote token mais avec juste un seul couple de quotes.
Ensuite on fera le truc avec count.
Parce que je crois que ça devrait fonctionner quand meme sur des trucs comme ls aaa'    'aaa ss'   'ss d'    'd





ls aaaa'aaaa'aaaa'aaaa'aaa wewee'eeee'eee'eeeee'



VERIFIER QUE LE TEMP DE COUNT[] EST BIEN PÉTÉ DANS LES FONCTIONS GET SIZE (LORSQUE LA QUOTE CHANGE)



en fait çe serait vraiment facile pour moi de faire une fonction ou je copie le tableau pour count, car je sais d'avance la taille du tableau, et peut etre sur la dernière fonction je peux a ce moment incrémenter 
count pour que ça reparte bien après dans la boucle de quote parsing



Ouai si je dois résumer je dois rechecker toutes les fonctions ou j'utilise count, car je crois que sur count je check pas et j'incremente/decremente pas lorsque le type change
le plus simple serait de juste copier le tableau a chaque fois que j'ai une fonction comme ça.





pour résumer ou j'utilise count, dans les size c'est seulement pour inside, mais pour copy c'est les deux.
Ce que je peux faire c'est d'utiliser les fonctions de copie de tableaux pour les 2 premiere fois, puis après j'utilise juste le tableau comme ça
Non je peux pas faire ça parce que count c'est pas la meme chose, car j'utilise ce tableau pour avoir la position de départ dans la cmd_str_b, ça n'a rien a voir 
avec les  count next quote. Donc cela veut dire que je suis quand meme obligé de faire une fonction ou j'incrément count avec count next count dans les types correspondants.


ah ouai aussi pour les copy des tableaux tant que j'y pense, je peux garder dans une struct les size des tableaux pour pouvoir les malloc facilements





Comme je viens de voir que l'on peut juste checker le type que l'on a pour les fonctions qui utilise count, car comme on cherche seulement la quote de départ, et bien osef des quotes de l'autre 
type. Je pense meme que je peux peux etre faire la meme chose pour quand j'utilise count dans copy outside





nouvelle erreur 

minishell$ ls pourquoi'allo'lol"pourquoi"allo
ls: cannot access 'pourquoiallololpourquoi': No such file or directory
minishell$ ls pourquoi'allo'lol'pourquoi'allo
celui la fonctionnait







----------------------------------

Oui donc verdict j'ai pas besoin de temp comme je disais le tableau de count parce que je l'utilise seulement pour aller sur le premier charactere lorsque j'en ai besoin.





------------------------------

Maintenant faire les env var



lol="'a'

ls ""''
ls ''""
ls '    ''    '
ls '   ''    '   '     ''    '
ls aaa'    '$lol'    'aaaa
ls '     '$lol'    '
ls aaaa'    $lol'   'aaa'     '$lol'    'aaaa
ls aaa'   ''   'aaa
ls aaa"   "'   'aaa
ls '   '"   "
ls "    "'   '
ls '     ''     '$lol'    '
ls'   ''   '

Faire des tests aussi lorsque $lol n'existepas

avec lol="'aaa '"

ls '   '$lol'   ' 


avec lol='"aa '

ls $lol'   'aaaa'    'aaaa a pas l'air de fonctionner. non ça fonctionne, c'était le deuxieme token apres ls les size javais pas compris







-Le problème c'est que j'utilise tab une fois et que après je dois le réutiliser mais les valeurs ne sont plus là, et aussi probablement tab est incrémenté.
	regarder ou j;utilise tab.

tab seulement dans if pass check

Et if pass check est utilisé dans les fonction outside, les deux.


Vu la fonction next pos, et son utilisation, je vais probablement pouvoir faire quelque chose comme temp juste le moment ou j'ai besoin pour le tab. et je 
pense que pour les questions de duplication du tableau pour ce qui viens après je pense que je pourrais faire ça quand je créer le tableau et je le met dans
une struct que je vais utiliser pour les futurs étapes du parsing.

Je pense que comme je temp deja le z dans q->pos, je peux probablement temp juste la valeur qu'il me faut dans next pos, et après incrémenter,  ou pas je sais pas, z.
Parce que comme les valeurs restes dans le tableau c'est juste le z qui va bouger. D'ailleurs ya peut etre moyen que j'ai pas besoin de dupliquer le tableau si je fais 
comme ça, j'aurais juste besoin de mettre le z a zéro quand je repasserais dans les tokens ou la cmd_strb

Voir si je peux temp la valeur du tableau dans les deux fonctions et juste bouger avec le z







////  QUEST CE QU'IL SE PASSE LORSQUE J'AI DES QUOTES DIFFÉRENTES DANS LES ENV VAR ? ENTRE LES ENVVAR ET LES VALID QUOTES ? A L'INTÉRIEUR DES ENVVAR ELLEMEMES ? COMMENT LE TAB EST INCR AVEC ÇA ?
///// TESTER AUSSI AVEC LES QUOTES ENVVAR A DES ENDROITS DIFFÉRENTS



Par contre je dois pas oublier d'incrémenter z après tout ça, peut etre en meme temps que je manage count, quelque chose comme ça.




ouai en fait le probleme c'est que pour le tab, je dois pouvoir décrémenter les values du tab selon ce que j'ai déjà mis dans le token valid de split




//// VERIF CHANGEMENT DE QUOTE TABLEAU (ENVVAR)
ouai ya pas l'air d'avoir de problemes, jai fait lol="'a'" et bite='"b"' attaché dans une commande ls et ça fonctionnait.

(on peut pas mettre deux type de quotes différentes (facilement) dans les env var sans avoir le backslash pour escaper)


Je pense qu'on est bon pour le parsing des quotes sans expand pour les doubles.
Je dois repasser tous les tests que j'ai fait, puis en remettre d'autre pour vraiment voir si c'est robuste. Puis passer à l'expand pour les double quotes.







--------

en fait je suis peutetre pas obligé de regarderpour les quotes non valide pour free les token de splir car de toute maniere elles seront collées au quote valid dans
les tokens, alors je peux les ignorer.






Avec tous les bugs que je viens de trouver sur les changmenet de type dans le free useless.
Non mais en fait il suffit que j'ai le nombre de quotes, en incluant les non valides, et j'ai pas besoin de szitcher entre les types normalement. Ah ouai
mais le probleme c'est que grace au tableau je sais pas si elle sont accrochées au token ou pas.
Ba non en fait normalement. 
Ba ouai alors ça voudrait dire que la meilleure faċon de faire ce serait d'ignorer les non valides ? Faudrait avoir la bonne position pour la quote valide alors



Pour le fait de décrémenter ou ne pas décrémenter le tab, je pense que pour mon cas qui ne fonctionne pas je dois faire quelque chose comme temp le tab seulement lorsque
je suis dnas le meme token split, et une fois que je suis sorti du token ça veut dire que osef. Quelque chose comme ça. Ça a l'air de fonctionner en sortie.

D'abord partir sur de bonne base, avec les tests qui fonctionne, regarder git diff, et ensuite comencer a voir comment fire







-------------

verifier que pour le problemede free j'ai bien le tableau deja, avec les valeurs, et que je peux regarder en arriere pour avoir la data si je veux. Sinon je vais devoir 
faire un count comme pour le decrem. Ah ouai mais attends je peux faire ça dans quote parsing je mets ça dans incr etc.. je sais pas, juste pour indiquer  le nombre de if pass
present avant la quote, comme ça j'ai pas besoin de garder la data du tableau et je pense que c'est la meilleure maniere de ne pas toucher au reste de la logique et donc de ne pas
introduire de bug



Et ensuite je devrais tester avec un grand nombre de quote, et dans tous les cas de figure, pourvoir si ça tient et que je gere l'entrée et la sortie.






Ok, visiblement le probleme pour le cas avec ' aa"' ça vient de l'incrémentation avec le tableau qui fait que ça incrément derriere alors que la quote non valide est pas 
dans le split token, elle est dans celui d'après.

avant de regarder ça deja voir si j'ai pas explosé des cas avec l'état du code maintenant







---ok en fait pour ce problemee ça a l'airdetre une histoirede type, parce si j'inverse le type dans lexempleça fonctionne (aa' au lieu de aa"

ouai quand j'inverse les quotes dans la commande ç aproduit la meme erreur:wa




Visiblement c'est a la sortie du premier token managé que je free pas les bonne choses






Peut etre que l'on peut jouer sur le fait que dansune env var il y aura forcément pour minishell suelement un seul type de quote, et donc si le compte est pair dans env var on fait rien


Mais je pense que ça va poser des problems a la sortie aussi, le programme a l'air de bien fonctionner sur les quotes non valides détachés des tokens, mais pour les changements de type
ça parait très compliqué, car meme si le type a l'interieur d'une env var peut pas changer on peu en avoir un nombre arbitraire, a des moments aribitraire dans la strings.
Peut etre le seul moyen serait de faire avec le tab, et construire une grosse fonction qui check tout ça


Je pense que je dois repartir sur mon idée de préserver les values du tabs une fois que j'arrive a la fonction ou type merde. Et aussi mon idée de savoir combien j'ai de quote
de tab au début dans le token était la bonne. Par contre pour les quotes de fin de token je ne sais pas vraiment comment faire, peut etre qu'il ne faut pas les compter dans
les counter et que a la place je décrémente le tableau pour que quand ça revient dans quote parsing on soit bien.
Pour faire ça, d'abord build


tester énormément de quote invalide

Ah ouai mais attends si ya deux env var avec des quote différentes collées ? c'est pas grave si je sais avec le tab de toute maniere je vais meme pas séparer les types.
Le seul truc chiant c'est vraiment de build l'entrée et la sortie, mais je pense que ce que j'ai dis la ça va fonctionner.


-------

-build préserver le tableau sur tout le long du traitement des quotes.  V
	all tests  (avoir les values sans rien en faire)        V
-build décrémentation et incrémentation du tableau pour avoir le nombre de quote a ignorer 
	all tests	(avoir les values sans rien en faire)
- utiliser ces values pour fix le test qui passe pas.



------
-tester avec une variable comme "'' '" pour voir si je decremente bien 2 et pas 3.
Oui ça fonctionne, donc sur la sortie ça va, mais je sais toujours pas si j'ai un systeme de decrementation dans la fonction
qui merde ça peut poser probleme

Oui je pense que je fais bien decr sur la sortie, mais j'utilise pas cette value sur la fonction qui merde.






Voila maintenant on arrive au stade ou je dois fix la fonction qui merde avec les types. Je pense que je dois mettre dans la fonction sur les types aussi un moyen de checker
lorsqu'on a une envvar entre des quotes valid (donc faire avec le tab skip des quotes quoi




Pour la question de decrementer le tableau entre les quotes, je crois que le tab a une case entre chaque couple de valid quotes, meme si elle font partie d'un seul quote token.
Verif ça.
Oui.
Ok donc ça veut dire que je dois faire une boucle ou je regarde pas le type lorsque c'est avant, au milieu, et a la fin du comptage de quotes (je rappelle je dois regarder le type 
dans ls quotes validees pour ne pas interpréter des quotes a l'interieur de quotes valides). Mais ça veut dire que je suis obligé d'avoir un systeme qui compte combien il y a de potentiels
"milieux"


Ah ouai mais ya un problème, je dois confirmer que la value du nombre de quotes a choper est bien wrong pour end (genre avec les trucs comme "'' '" il va compter la 3e quote en sortie 


En fait j'ai meme pas besoin de checker pour les invalid quotes qui viennent derriere parce que de toute maniere elles seront incluse bien dans le token, et comme je produis la value pour le
nombre de quotes invalides après les quotes valides dans le token de quote autre part on est bon je pense.
Donc je dois:

-rebuild increment tab func to not include after token potential invalid quotes
-build pass before valid quotes
-build middle of multiple quotes infra



(je me souviens plus est ce que je compte les quotes avant les premieres valid quotes dans le increment with tab ou pas)
Non seulement celles après. Je dois refaire cette fonction pour quelle prenne pas en compte les invalid quote après et par contre celle avant,
mais je dois revif que le tab defonce pas la data sur les quotes avants ? non parce que cette data la est dans la variable q_begin_tok, si je 
regarde juste le tab ça pourrait faire des erreurs.





---------------------------

Ok verdict.
Je pense que j'ai fix le cas, mais je pense qu'on a pas du tout besoin de checker pour les quotes invalid avant et après, par contre
on doit decrementer en sortie le tab pour pas que ça plante après et on a besoin de checker pour une env var éventuelles
au milieu des multiples couples de quotes.
Comme on est sur que les non valid quotes sont dans les token que je vais free on peut les ignorer je pense, et le code que
j'ai écrit la dessus ne sert a rien. Mais on a besoin de ça pour le milieu.
Avancer de build pour le milieu je vais déjà tout retester.






-----
-Plus que build les middle envvar avec quote et je m'arrete la, je test pas plus, j'ai testé avec des quotes variables, plusieurs envvar avec different types de quote, et ça pete pas.
Donc a partir de maitenenant je pas rajouter de test et je vais pas tout retester a chaque fois, je ferais ça une derniere fois quand jaurais fini les quotes. Donc pas besoin de tester les
envvar diff type quotes multiple etc.









Pour le middle des envvar, je dois d'abord chhecker si je dois temp ou pas le tableau.


Ouai on va temp. ça me parait beaucoup plus simple.

Juste içi au passage, après un call a manage quote en fait je manipule la data du tableau, jsute pour que if pass ai les bonne values, je pense que c'est pas grave de changer
le tableau comme ça, parce que j'ai vraiment plus besoin de cette data après, et si j'ai besoin du tableau après dans le reste du parsing je peux toujours faciement le duppliquer
lorsque je calcule le tableau.


Ouai, je vais pas m'enmerder a interpoler les test entre espaces, différents types dans non valid, différent type dans valid. je vais juste noter les tests que je viens de faire et qui fonctionnait pas et puis voila.





// je comprends pas encore pourquoi ls $lol"      "$lol"    "$lol fonctionne pas, quand je regarde mon code tout est bizarre, on est pas dans les bons token, mais le nombre de count quote est comme si on etait dans le bon
etc..  mais le state du program la est celui qui passe le plus de test












-------------------------------

mettre ()&& v->split_str[x] dans la boucle while de  ça repare un peu mais ya toujours une erreur valgrind, c'est juste un pansement ce moyen la, je dois regarder pourquoi le programme incrémente trop






---------------------------


Ok, le programme a l'air de fonctionner très bien lorsque toutes les quotes sont du meme types, c'est juste que le type est changé dans le cas avec plusieurs types et donc ça merde après. Peut etre je peux faire
quelque chose a la place comme le resultat du modulo est une variable que je set selon le nombre d'env var quote ?





-------

ok ça `a l'air de focntionner, j'ai essayer avec des quotes de 1 a 5, avec les inverses, avec 2 variables avec les quotes differnetes dedans, avec des quotes valides differentes, etc.. 
Si je passe tous les autres test je m'arrete la.

juste tester ce que je faisais mais avec quelque chose dans les quotes.

C'est bon ça passe les tests avec les quotes pleins. 
Sije passe les reste des tests j'arrête.






(on va faire un truc, je vais laisser passer le programme dans mes fix seulement lorsqu'il y a des envvar, meme si je pense pas que ç afonctionne très bien sur le type de truc
qui pete alors qu'il y a pas une variable entre chaque quote mais seullement quelque quote, tester ça et tester d'abord toutes les variables avant de build ce fix, parce que ç asert
a rien sinon





----------

deuxchoses a faire,

essayer de trouver un moyen de garder le fix mais de choperles tokens après, ptet avec pos de la fin (ptet avec le x), pour eviter de changer toutle code
-si ça fonctionne pas, essayer de réparer le programme pour qu'il prenne pas en compte invalid quote débutet fin 









-============================

ouaui le test avec lol="" enfait ça m'a fait découvrir un bug dans les env var probablemement, juste checkerça vite fait en continuer avec le testing des quotes, mais je pense que cest joueé, tout fonctionnait jai justepas test 5 mais as de raison que ca fonctionne pas, tout rester aprèd






minishell$ ls"    "'   '









PROBLEME:


made-f0Ar10s12% make valgrind 
minishell$ lsdddddddddddddddddd'        'dddddddddddddddddddddddddddddddddddddddddddd
minishell$ ls dddddddddddddddddd'        'dddddddddddddddddddddddddddddddddddddddddddd
ls: cannot access 'dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd        ': No such file or directory
minishell$ 
make: *** [Makefile:143: valgrind] Error 2
made-f0Ar10s12% nvim log
made-f0Ar10s12% make valgrind
minishell$ ls dddddddddddddddddd'        'dddddddddddddddddddddddddddddddddddddddddddd
ls: cannot access 'dddddddddddddddddd        dddddddddddddddddddddddddddddddddddddddddddd': No such file or directory
minishell$ ls dddddddddddddddddd'        'dddddddddddddddddddddddddddddddddddddddddddd
ls: cannot access 'dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd        ': No such file or directory
minishell$ 
make: *** [Makefile:143: valgrind] Error 2
made-f0Ar10s12% nvi


il doit y avoir une valeure que j'oublie de remettre a zéro ou quelque chose comme ça


ouai :


minishell$ ls dd'     'dddddd
ls: cannot access 'dd     dddddd': No such file or directory
minishell$ ls s'       'sssssss
ls: cannot access 's       ss': No such file or directory
minishell$ 
